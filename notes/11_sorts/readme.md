# 排序（上）

| 排序算法 | 时间复杂度 | 是否基于比较 |
|---------|----|----|
| 冒泡、插入、选择 | $O(n^2)$ | [y] |
| 快排、归并 | $O(n\log n)$ | [y] |
| 桶、基数、计数 | $O(n) | [x] |

开篇问题：插入排序和冒泡排序的时间复杂度相同，都是 $O(n^2)$，在实际软件开发中，为什么我们更倾向于使用插入排序而不是冒泡排序？

## 如何分析「排序算法」？

### 算法执行效率

1. 最好、最坏、平均情况的时间复杂度
2. 时间复杂度的系数、低阶、常数——在渐进复杂度相同的情况下，需要比较系数、低阶和常数
3. 比较和交换（移动）的次数——基于比较的排序算法的两种基本操作

### 算法的内存消耗

是否为原地排序算法（In-place sort algorithm），即算法的空间复杂度是否为 $O(1)$。

### 排序的稳定性

经过排序算法处理后，值相同的元素，在原序列和排序后序列中的相对位置保持不变，则称该排序算法是稳定的。

> 待排序的 `item` 并不是简单的值，而是一个基于对象中的某个 `key` 进行排序时，排序的稳定性就有意义了。
